package model

import (
	"database/sql"
	"errors"
	"time"

	"github.com/didi/gendry/builder"
	"github.com/didi/gendry/scanner"
)

/*
This code is generated by gendry
*/

// Transaction is a mapping object for transaction table in mysql
type Transaction struct {
	ID          int       `json:"id"`
	Action      int8      `json:"action"`
	OrderID     string    `json:"order_id"`
	ServiceType int8      `json:"service_type"`
	Coins       int       `json:"coins"`
	Credits     int       `json:"credits"`
	CreateTime  time.Time `json:"create_time"`
}

//action_user: 0.充值 1:下单 2:订单过期退款 3:加急  4:加急退款  5.订单打赏
//action_adviser: 0.充值 1:完成订单 2:完成加急订单 3:收到打赏

//GetOne gets one record from table transaction by condition "where"
func GetOneTransaction(db *sql.DB, where map[string]interface{}) (*Transaction, error) {
	if nil == db {
		return nil, errors.New("sql.DB object couldn't be nil")
	}
	cond, vals, err := builder.BuildSelect("transaction", where, nil)
	if nil != err {
		return nil, err
	}
	row, err := db.Query(cond, vals...)
	if nil != err || nil == row {
		return nil, err
	}
	defer row.Close()
	var res *Transaction
	err = scanner.Scan(row, &res)
	return res, err
}

//GetMulti gets multiple records from table transaction by condition "where"
func GetMultiTransaction(db *sql.DB, where map[string]interface{}) ([]*Transaction, error) {
	if nil == db {
		return nil, errors.New("sql.DB object couldn't be nil")
	}
	cond, vals, err := builder.BuildSelect("transaction", where, nil)
	if nil != err {
		return nil, err
	}
	row, err := db.Query(cond, vals...)
	if nil != err || nil == row {
		return nil, err
	}
	defer row.Close()
	var res []*Transaction
	err = scanner.Scan(row, &res)
	return res, err
}

//Insert inserts an array of data into table transaction
func InsertTransaction(db *sql.DB, data []map[string]interface{}) (int64, error) {
	if nil == db {
		return 0, errors.New("sql.DB object couldn't be nil")
	}
	cond, vals, err := builder.BuildInsert("transaction", data)
	if nil != err {
		return 0, err
	}
	result, err := db.Exec(cond, vals...)
	if nil != err || nil == result {
		return 0, err
	}
	return result.LastInsertId()
}

//Update updates the table transaction
func UpdateTransaction(db *sql.DB, where, data map[string]interface{}) (int64, error) {
	if nil == db {
		return 0, errors.New("sql.DB object couldn't be nil")
	}
	cond, vals, err := builder.BuildUpdate("transaction", where, data)
	if nil != err {
		return 0, err
	}
	result, err := db.Exec(cond, vals...)
	if nil != err {
		return 0, err
	}
	return result.RowsAffected()
}

// Delete deletes matched records in transaction
func DeleteTransaction(db *sql.DB, where, data map[string]interface{}) (int64, error) {
	if nil == db {
		return 0, errors.New("sql.DB object couldn't be nil")
	}
	cond, vals, err := builder.BuildDelete("transaction", where)
	if nil != err {
		return 0, err
	}
	result, err := db.Exec(cond, vals...)
	if nil != err {
		return 0, err
	}
	return result.RowsAffected()
}
